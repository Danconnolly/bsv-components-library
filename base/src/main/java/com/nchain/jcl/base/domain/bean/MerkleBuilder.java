package com.nchain.jcl.base.domain.bean;


import com.nchain.jcl.base.domain.api.base.Tx;
import com.nchain.jcl.base.tools.bytes.ByteTools;
import com.nchain.jcl.base.tools.crypto.Sha256;
import com.nchain.jcl.base.tools.crypto.Sha256Wrapper;

import java.util.ArrayList;
import java.util.List;

/**
 * Naive and inefficient implementation ripped from legacy BitcoinJ and basically replicates the first bitocind
 * implementation.  Better one coming soon.
 */
public class MerkleBuilder {

    public static Sha256Wrapper calculateMerkleRootFromTxs(List<Tx> txs) {
        List<Sha256Wrapper> hashes = new ArrayList<>(txs.size());
        for (Tx tx: txs)
            hashes.add(tx.getHash());
        return calculateMerkleRoot(hashes);
    }

    public static Sha256Wrapper calculateMerkleRoot(List<Sha256Wrapper> hashes) {
        List<byte[]> tree = buildMerkleTree(hashes);
        return Sha256Wrapper.wrap(tree.get(tree.size() - 1));
    }

    private static List<byte[]> buildMerkleTree(List<Sha256Wrapper> hashes) {
        // The Merkle root is based on a tree of hashes calculated from the transactions:
        //
        //     root
        //      / \
        //   A      B
        //  / \    / \
        // t1 t2 t3 t4
        //
        // The tree is represented as a list: t1,t2,t3,t4,A,B,root where each
        // entry is a hash.
        //
        // The hashing algorithm is double SHA-256. The leaves are a hash of the serialized contents of the transaction.
        // The interior nodes are hashes of the concenation of the two child hashes.
        //
        // This structure allows the creation of proof that a transaction was included into a block without having to
        // provide the full block contents. Instead, you can provide only a Merkle branch. For example to prove tx2 was
        // in a block you can just provide tx2, the hash(tx1) and B. Now the other party has everything they need to
        // derive the root, which can be checked against the block header. These proofs aren't used right now but
        // will be helpful later when we want to download partial block contents.
        //
        // Note that if the number of transactions is not even the last tx is repeated to make it so (see
        // tx3 above). A tree with 5 transactions would look like this:
        //
        //         root
        //        /     \
        //       1        5
        //     /   \     / \
        //    2     3    4  4
        //  / \   / \   / \
        // t1 t2 t3 t4 t5 t5
        ArrayList<byte[]> tree = new ArrayList<byte[]>();
        // Start by adding all the hashes of the transactions as leaves of the tree.
        for (Sha256Wrapper hash : hashes) {
            if (hash == null)
                System.out.println();
            tree.add(hash.getBytes());
        }
        int levelOffset = 0; // Offset in the list where the currently processed level starts.
        // Step through each level, stopping when we reach the root (levelSize == 1).
        for (int levelSize = hashes.size(); levelSize > 1; levelSize = (levelSize + 1) / 2) {
            // For each pair of nodes on that level:
            for (int left = 0; left < levelSize; left += 2) {
                // The right hand node can be the same as the left hand, in the case where we don't have enough
                // transactions.
                int right = Math.min(left + 1, levelSize - 1);
                byte[] leftBytes = ByteTools.reverseBytes(tree.get(levelOffset + left));
                byte[] rightBytes = ByteTools.reverseBytes(tree.get(levelOffset + right));
                tree.add(ByteTools.reverseBytes(Sha256.hashTwice(leftBytes, 0, 32, rightBytes, 0, 32)));
            }
            // Move to the next level.
            levelOffset += levelSize;
        }
        return tree;
    }

}
