package com.nchain.jcl.store.foundationDB.blockStore

import com.apple.foundationdb.Database
import com.nchain.jcl.base.domain.api.base.Tx
import com.nchain.jcl.base.tools.crypto.Sha256Wrapper
import com.nchain.jcl.store.blockStore.BlockStore
import com.nchain.jcl.store.foundationDB.common.TestingUtils
import spock.lang.Specification

import java.util.concurrent.atomic.AtomicInteger
import java.util.stream.Collectors

/**
 * Testig class with Scenarios specific for Txs
 */
class BlockStoreTxsSpec extends Specification {


    /**
     * We test that TXs are properly saved and removed into the DB and the related Events are properly triggered.
     */
    def "testing saving/removing Txs"() {
        given:
            println(" - Connecting to the DB...")
            BlockStoreFDBConfig config = BlockStoreFDBConfig.builder()
                    .networkId("BSV-Mainnet")
                    .build()
            BlockStore blockStore = BlockStoreFDB.builder()
                    .config(config)
                    .triggerTxEvents(true)
                    .build()

            // We keep track of the Events triggered:
            AtomicInteger numTxsSavedEvents = new AtomicInteger()
            AtomicInteger numTxsRemovedEvents = new AtomicInteger();
            blockStore.EVENTS().TXS_SAVED.forEach({e -> numTxsSavedEvents.incrementAndGet()})
            blockStore.EVENTS().TXS_REMOVED.forEach({e -> numTxsRemovedEvents.incrementAndGet()})

        when:
            blockStore.start()
            //TestingUtils.clearDB(blockStore.db)

            // We define 3 Txs:
            Tx tx1 = TestingUtils.buildTx()
            Tx tx2 = TestingUtils.buildTx()
            Tx tx3 = TestingUtils.buildTx()

            // We save 1 individual Txs:
            long numTxsBeforeAll = blockStore.getNumTxs()
            boolean isTx1FoundBeforeInserting = blockStore.containsTx(tx1.getHash())
            blockStore.saveTx(tx1)
            long numTxsAfter1Tx = blockStore.getNumTxs()
            boolean isTx1FoundAfterInserting = blockStore.containsTx(tx1.getHash())

            // We save the remaining 2 Txs in a single batch:
            blockStore.saveTxs(Arrays.asList(tx2, tx3))
            long numTxsAfter3Txs = blockStore.getNumTxs()

            blockStore.printKeys()

            // We remove one Tx individually:
            blockStore.removeTx(tx2.getHash())
            long numTxsAfterRemove1Tx = blockStore.getNumTxs()

            // The 2 remaining Txs are removed in a single Batch:
            blockStore.removeTxs(Arrays.asList(tx1.getHash(), tx3.getHash()))
            long numTxsAfterRemove3Tx = blockStore.getNumTxs()

            blockStore.printKeys()


        then:
            numTxsBeforeAll == 0
            numTxsAfter1Tx == 1
            !isTx1FoundBeforeInserting
            isTx1FoundAfterInserting
            numTxsAfter3Txs == 3
            numTxsSavedEvents.get() == 2
            numTxsSavedEvents.get() == 2
            numTxsAfterRemove1Tx == 2
            numTxsAfterRemove3Tx == 0
        cleanup:
            blockStore.removeTxs(Arrays.asList(tx1.getHash(), tx2.getHash(), tx3.getHash()))
            blockStore.printKeys()
            blockStore.stop()
    }

    /**
     * We test that we save several Txs, some of them spending the outputs of others, and then we check that we can
     * recover this information.
     */
    def "testing Txs Needed"() {
        final int NUM_TXS = 3
        given:
            println(" - Connecting to the DB...")
            BlockStoreFDBConfig config = BlockStoreFDBConfig.builder()
                    .networkId("BSV-Mainnet")
                    .build()
            BlockStore blockStore = BlockStoreFDB.builder()
                    .config(config)
                    .triggerTxEvents(true)
                    .build()
        when:
            blockStore.start()
            //TestingUtils.clearDB(blockStore.db)
            // We save several Txs: after the First, each one is using an output generated by the previous Txs...
            List<Tx> txs = new ArrayList<>()
            for (int i = 0; i < NUM_TXS; i++) {
                String parentTxHash = (i == 0) ? null : txs.get(i - 1).getHash().toString();
                txs.add(TestingUtils.buildTx(parentTxHash))
            }
            // We save all the Txs
            blockStore.saveTxs(txs)
            blockStore.printKeys()

            // Now we recover each of them, checking that the info about the Txs Needed is correct for each one...
            Boolean OK = true
            List<Sha256Wrapper> txHashes = txs.stream().map({ tx -> tx.getHash()}).collect(Collectors.toList())
            for (int i = 0; i < NUM_TXS; i++) {
                Tx tx = blockStore.getTx(txHashes.get(i)).get()
                List<Sha256Wrapper> txsNeeded = blockStore.getTxsNeeded(tx.getHash())
                if (i > 0) {
                    OK &= txsNeeded.size() == 1 &&  txsNeeded.get(0).equals(txHashes.get(i - 1))
                }
            }
        then:
            OK
        cleanup:
            blockStore.removeTxs(txs.stream().map({tx -> tx.getHash()}).collect(Collectors.toList()))
            blockStore.printKeys()
            blockStore.stop()
    }
}
