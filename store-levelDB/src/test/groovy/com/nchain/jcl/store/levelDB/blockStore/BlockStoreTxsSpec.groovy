package com.nchain.jcl.store.levelDB.blockStore

import com.google.common.io.MoreFiles
import com.google.common.io.RecursiveDeleteOption
import com.nchain.jcl.base.domain.api.base.Tx
import com.nchain.jcl.base.tools.crypto.Sha256Wrapper
import com.nchain.jcl.store.blockStore.BlockStore
import com.nchain.jcl.store.levelDB.common.TestingUtils
import spock.lang.Specification

import java.nio.file.Path
import java.util.concurrent.atomic.AtomicInteger
import java.util.stream.Collectors

/**
 * Testig class with Scenarios specific for Txs
 */
class BlockStoreTxsSpec extends Specification {
    /**
     * We test that TXs are properly saved and removed into the DB and the related Events are properly triggered.
     */
    def "testing saving/removing Txs"() {
        given:
            // Configuration and DB start up:
            Path dbPath = Path.of(TestingUtils.buildWorkingFolder())
            BlockStoreLevelDBConfig dbConfig = BlockStoreLevelDBConfig.builder()
                    .workingFolder(dbPath)
                    .build()
            BlockStore db = BlockStoreLevelDB.builder()
                    .config(dbConfig)
                    .triggerTxEvents(true)
                    .build()

            // for keeping track of the Events triggered:
            AtomicInteger numTxsStoredEvents = new AtomicInteger()
            AtomicInteger numTxsRemovedEvents = new AtomicInteger()

            db.EVENTS().TXS_SAVED.forEach({e -> numTxsStoredEvents.incrementAndGet()})
            db.EVENTS().TXS_REMOVED.forEach({e -> numTxsRemovedEvents.incrementAndGet()})

        when:
            // We save one Tx, and then we retrieve it:
            Tx tx1 = TestingUtils.buildTx()
            db.saveTx(tx1)
            Tx txInserted = db.getTx(tx1.getHash()).get()

            // We check that the Block retrieved is actually the one we inserted:
            boolean found = txInserted != null && txInserted.equals(tx1)

            // Now we remove it and we check that it's been actually removed:
            db.removeTx(tx1.getHash())
            boolean removedAfter = db.getTx(tx1.getHash()).isEmpty()

            // We do the same here, but using the methods that accept a List of objects

            Tx tx2 = TestingUtils.buildTx()
            db.saveTxs(Arrays.asList(tx2))
            db.removeTxs(Arrays.asList(tx2.getHash()))
            // We wait a bit, to give the events enought time to reach their callbacks:
            Thread.sleep(100)
        then:
            found
            removedAfter
            numTxsStoredEvents.get() == 2
            numTxsRemovedEvents.get() == 2
        cleanup:
            MoreFiles.deleteRecursively(dbPath, RecursiveDeleteOption.ALLOW_INSECURE)
    }

    /**
     * We test that we save several Txs, some of them spending the outputs of others, and then we check that we can
     * recover this information.
     */
    def "testing Txs Needed"() {
        final int NUM_TXS = 3
        given:
            // Configuration and DB start up:
            Path dbPath = Path.of(TestingUtils.buildWorkingFolder())
            BlockStoreLevelDBConfig dbConfig = BlockStoreLevelDBConfig.builder()
                    .workingFolder(dbPath)
                    .build()
            BlockStore db = BlockStoreLevelDB.builder()
                    .config(dbConfig)
                    .triggerTxEvents(true)
                    .build()
        when:
            db.start()
            // We save several Txs: after the First, each one is using an output generated by the previous Txs...
            List<Tx> txs = new ArrayList<>()
            for (int i = 0; i < NUM_TXS; i++) {
                String parentTxHash = (i == 0) ? null : txs.get(i - 1).getHash().toString();
                txs.add(TestingUtils.buildTx(parentTxHash))
            }
            db.saveTxs(txs)

            db.printKeys()

            // Now we recover each of them, checking that the info about the Txs Needed is correct for each one...
            Boolean OK = true
            List<Sha256Wrapper> txHashes = txs.stream().map({tx -> tx.getHash()}).collect(Collectors.toList())
            for (int i = 0; i < NUM_TXS; i++) {
                Tx tx = db.getTx(txHashes.get(i)).get()
                List<Sha256Wrapper> txsNeeded = db.getTxsNeeded(tx.getHash())
                if (i > 0) {
                    OK &= txsNeeded.size() == 1 &&  txsNeeded.get(0).equals(txHashes.get(i - 1))
                }
            }

            db.stop()
        then:
            OK
        cleanup:
            MoreFiles.deleteRecursively(dbPath, RecursiveDeleteOption.ALLOW_INSECURE)
    }
}
